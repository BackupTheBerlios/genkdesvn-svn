# Copyright 1999-2005 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Header: /var/cvsroot/gentoo-x86/eclass/subversion.eclass,v 1.18 2005/01/20 09:53:16 hattya Exp $

## --------------------------------------------------------------------------- #
# Author: Akinori Hattori <hattya@gentoo.org>
# 
# The subversion eclass is written to fetch the software sources from
# subversion repositories like the cvs eclass.
#
#
# Description:
#   If you use this eclass, the ${S} is ${WORKDIR}/${P}.
#   It is necessary to define the ESVN_REPO_URI variable at least.
#
## --------------------------------------------------------------------------- #

inherit eutils scm

ECLASS="subversion"
INHERITED="${INHERITED} ${ECLASS}"
ESVN="subversion.eclass"

EXPORT_FUNCTIONS src_unpack

DESCRIPTION="Based on the ${ECLASS} eclass"


## -- add subversion in DEPEND
#
DEPEND="dev-util/subversion"


## -- ESVN_STORE_DIR:  subversion sources store directory
#
ESVN_STORE_DIR="${DISTDIR}/svn-src"


## -- ESVN_FETCH_CMD:  subversion fetch command
#
# default: svn checkout
#
[ -z "${ESVN_FETCH_CMD}" ]  && ESVN_FETCH_CMD="svn checkout"

## -- ESVN_UPDATE_CMD:  subversion update command
#
# default: svn update
#
[ -z "${ESVN_UPDATE_CMD}" ] && ESVN_UPDATE_CMD="svn update"


## -- ESVN_REPO_URI:  repository uri
#
# e.g. http://foo/trunk, svn://bar/trunk
#
# supported protocols:
#   http://
#   https://
#   svn://
#
[ -z "${ESVN_REPO_URI}" ]  && ESVN_REPO_URI=""


## -- ESVN_PROJECT:  project name of your ebuild
#
# subversion eclass will check out the subversion repository like:
#
#   ${ESVN_STORE_DIR}/${ESVN_PROJECT}/${ESVN_REPO_URI##*/}
#
# so if you define ESVN_REPO_URI as http://svn.collab.net/repo/svn/trunk or
# http://svn.collab.net/repo/svn/trunk/. and PN is subversion-svn.
# it will check out like:
#
#   ${ESVN_STORE_DIR}/subversion/trunk
#
# default: ${PN/-svn}.
#
[ -z "${ESVN_PROJECT}" ] && ESVN_PROJECT="${PN/-svn}"


## -- ESVN_BOOTSTRAP:
#
# bootstrap script or command like autogen.sh or etc..
#
[ -z "${ESVN_BOOTSTRAP}" ] && ESVN_BOOTSTRAP=""


## -- ESVN_PATCHES:
#
# subversion eclass can apply pathces in subversion_bootstrap().
# you can use regexp in this valiable like *.diff or *.patch or etc.
# NOTE: this patches will apply before eval ESVN_BOOTSTRAP.
#
# the process of applying the patch is:
#   1. just epatch it, if the patch exists in the path.
#   2. scan it under FILESDIR and epatch it, if the patch exists in FILESDIR.
#   3. die.
#
[ -z "${ESVN_PATCHES}" ] && ESVN_PATCHES=""


## -- subversion_svn_fetch() ------------------------------------------------- #

#function subversion_module_fetch() {

#	local module=$1
#	local mode=$2
#	local parent=`dirname $module`
#	[ -z $2 ] && mode=""

	# If parent doesn't exist
#	if [ ! -d "$parent" ]; then
		#subversion_module_fetch $parent "-N"
#	fi

	#if [ -d $module ]; then
		#einfo "Updating module $module"
	#else
		#einfo "Checking out module $module"
	#fi
#	${ESVN_UPDATE_CMD} $mode $module

#}

function subversion_module_fetch_direct() {

	local module=$1
	local mode=""
	local parent=`dirname $module`
	[ -n $2 ] && mode="$2"

	is_recently_updated $module
	if [ $? == $TRUE ]; then

		ewarn "Updating module $module [skip]"

	else
	
		if [ -d $module ]; then
		
			einfo "Updating module $module"

		else

			einfo "Checking out module $module"

		fi
		#${ESVN_UPDATE_CMD} $mode $module

	fi
	#${ESVN_UPDATE_CMD} $mode $module

}

[ -z $ESVN_INTERVAL ] && ESVN_INTERVAL=1800
function is_recently_updated() {

	dir=""
	
	[ -n $1 ] && dir="$1/"
	if [ -e "$dir.svn/entries" ] && (( $(date +%s) - $(date -r $dir.svn/entries +%s) < $ESVN_INTERVAL )); then

		return $TRUE

	else

		return $FALSE

	fi

}

# Constants
readonly DNE=0 FIL=1 DIR=2
readonly FALSE=0 TRUE=1

# item_type_from_listing(): Determine if item is a file, directory, or doesn't exist.
# Do so by quering the server/work copy listing of files.
#
# Requirements:
#	Running folder must be a subversion folder.
#
# Parameters:
#	$1 - item to inspect
#	$2 - Repository URL
#
# Return:
#	$DNE - item does not exist
#	$FIL - item is a file
#	$DIR - item is a directory
#
function item_type_from_listing(){

	debug-print-function $FUNCNAME $*

	# Item to search listings for
	local item=$1

	# Repository URL
	local url=""

	# If URL passed to function, append /
	[ -n "$2" ] && url="$2/"

	# Base name of item (with its location stripped)
	local name=`basename $item`

	# Directory above item in the file hierarchy
	local topdir=`dirname $item`

	# Grab list of contents of $topdir from cached server results if posible
	# Cache consists of lines of the form $topdir item1 item2 ... itemN
	local cachefile="$T/.svn.list.cache"
	local topdirlist=""

	# If cache exists
	if [ -f $cachefile ]; then
	
		# Read all lines from the cache file, until an entry is found
		exec < $cachefile
		while read line && [ "$topdirlist" == "" ]
		do

			local pivot=true

			echo "line is: $line"
			# For every entry in a matching cache line
			for item in line
			do

				echo "item is: $item, pivot is $pivot"
				# If pivot entry in line and it doesn't match $topdir, break out
				$pivot && pivot=false && ( [ $item != $topdir ] && break || continue )

				# Transfer $item to local cache for $topdir 
				topdirlist="$topdirlist $item"	

			done

		done

	fi
	
	# If cache entry for listing of $topdir found
	if [ "$topdirlist" != "" ]; then

		debug-print "Found cache entry for listing of $topdir in $cachefile"

	# If cache entry for listing of $topdir not found
	else 

		# Grab list of contents of $topdir from server
		echo "Executing svn list $url$topdir"
		debug-print "Querying $url$topdir for listing"
		topdirlist=`svn list $url$topdir || die \"Unable to obtain list of items in $topdir from server\"`

		# Create listing cache entry for $topdir
		local cacheentry="$topdir"
		for item in $topdirlist
		do

			cacheentry="$cacheentry $item"

		done

		# Add entry for $topdir to listing cachefile
		debug-print "Adding cache entry for $topdir to $cachefile"
		echo $cacheentry >> $cachefile

	fi

	# If item $name is present in list, claim it is a file
	if ( hasq "$name" $topdirlist ); then

		debug-print "Determined that $item is a file on server"
		return $FIL

	# If item $name with a trailing / is present in list, claim it is a directory
	elif ( hasq "$name/" $topdirlist ); then

		debug-print "Determined that $item is a directory on server"
		return $DIR

	# Otherwise, claim $item does not exist
	else

		debug-print "Determined that $item does not exist on server"
		return $DNE

	fi

}

# item_type(): Determine if item is a file, directory, or doesn't exist.
# Attempt to determine said information from file-system if possible,
# otherwise query the subversion repository for that information.
#
# Requirements:
#	Running folder must be a subversion folder.
#
# Parameters:
#	$1 - item to inspect
#	$2 - Repository URL
#
# Return:
#	$DNE - item does not exist
#	$FIL - item is a file
#	$DIR - item is a directory
#
function item_type() {

	debug-print-function $FUNCNAME $*

	# Item to inspect
	local item=$1

	# Repository URL
	local url=$2

	# Base name of item (with its location stripped)
	local name=`basename $item`

	# Directory above item in the file hierarchy
	local topdir=`dirname $item`

	# If $item exists locally, and is a file, claim it is a file
	if [ -f $item ]; then
	
		debug-print "Determined that $item is a local file"
		return $FIL

	# If $item exists locally, and is a directory, claim it is a directory
	elif [ -d $item ]; then

		debug-print "Determined that $item is a local directory"
		return $DIR
	
	# If $topdir is actually a file, claim $item does not exist
	elif [ -f $topdir ]; then

		debug-print "Determined that $topdir is a file, thus $item does not exist"
		return $DNE

	# If $topdir is a working copy
	# and status of $item is blank, claim $item does not exist
	elif [ -f "$topdir/.svn/entries" ]; then
	
		echo "Execute svn -v status $topdir"
		# If status of $item is blank, claim it does not exist
		if [ "`svn -v status $topdir || die \"Unable to obtain status of $topdir from server\"`" == "" ]; then

			debug-print "Determined that $topdir is a working folder, but $item does not exist"
			return $DNE

		# Otherwise return result as determined from local subversion listing
		else

			item_type_from_listing $item
			return $?

		fi

	# If still undetermined, fully query server repository
	else

		echo "Execute svn list $url/$topdir"
		local listresp="`svn list $url/$topdir 2>$T/.svn.error`"

		# If failure listing $topdir
		if [ $? == 1 ]; then
		
			# If $topdir does not exist in server repository, claim it does not exist
			if [ $listresp == "" ]; then

				debug-print "Determined that $topdir and thus $item do not exist"
				return $DNE

			# If unknown failure listing $topdir
			else

				die "Unable to obtain listing for $topdir from server"

			fi
	
		# If topdir exists on server repository, determine what $item really is
		else 

			item_type_from_listing $item $url
			return $?

		fi
	
	fi
 
}

function subversion_deep_copy() {

	debug-print-function $FUNCNAME $*

	local item="$1"
	local src="$2"
	local dest="$3"

	einfo "Copying $item to $dest"
	debug-print "Deep-copying $item from $src to $dest, omitting .svn*"

	pushd $src >/dev/null
	find $item \( -path "*.svn*" ! -name . -prune \) -o \( -exec \cp --parents {} $dest/ \;  \) >/dev/null 2>&1
	popd >/dev/null

}

declare -a deep_items shallow_items
declare -i deep_levels shallow_levels
function subversion_svn_fetch() {

	# ESVN_REPO_URI is empty.
	[ -z "${ESVN_REPO_URI}" ] && die "${ESVN}: ESVN_REPO_URI is empty."

	# check for the protocol.
	case ${ESVN_REPO_URI%%:*} in
		http)	;;
		https)	;;
		svn)	;;
		*)
			die "${ESVN}: fetch from "${ESVN_REPO_URI%:*}" is not yet implemented."
			;;
	esac

	if [ ! -d "${ESVN_STORE_DIR}" ]; then
		debug-print "${FUNCNAME}: initial checkout. creating subversion directory"

		addwrite /
		mkdir -p "${ESVN_STORE_DIR}"      || die "${ESVN}: can't mkdir ${ESVN_STORE_DIR}."
		chmod -f o+rw "${ESVN_STORE_DIR}" || die "${ESVN}: can't chmod ${ESVN_STORE_DIR}."
		export SANDBOX_WRITE="${SANDBOX_WRITE%%:/}"
	fi

	cd -P "${ESVN_STORE_DIR}" || die "${ESVN}: can't chdir to ${ESVN_STORE_DIR}"
	ESVN_STORE_DIR=${PWD}

	# every time
	addwrite "/etc/subversion"
	addwrite "${ESVN_STORE_DIR}"

	# -userpriv
	! has userpriv ${FEATURE} && addwrite "/root/.subversion"

	[ -z "${ESVN_REPO_URI##*/}" ] && ESVN_REPO_URI="${ESVN_REPO_URI%/}"
	ESVN_CO_DIR="${ESVN_PROJECT}/${ESVN_REPO_URI##*/}"

	[ -n "$ESVN_MODULES" ] && ESVN_FETCH_OPTS="-N" && ESVN_UPDATE_OPTS="-N"
	# First update trunk

	# If trunk does not yet exist, perform initial checkout
	if [ ! -d "${ESVN_CO_DIR}/.svn" ]; then

		einfo "Creating $ESVN_PROJECT trunk in $ESVN_STORE_DIR/$ESVN_CO_DIR from $ESVN_REPO_URI"

		mkdir -p "${ESVN_PROJECT}"
		cd "${ESVN_PROJECT}"
		echo "Executing ${ESVN_FETCH_CMD} $ESVN_FETCH_OPTS ${ESVN_REPO_URI}"
		${ESVN_FETCH_CMD} $ESVN_FETCH_OPTS "${ESVN_REPO_URI}" || die "${ESVN}: can't fetch from ${ESVN_REPO_URI}."

	# Otherwise update its working copy
	else

		cd "${ESVN_CO_DIR}"

		is_recently_updated
		if [ $? == $TRUE ]; then

			ewarn "Updating $ESVN_PROJECT trunk from $ESVN_REPO_URI [skip]"

		else 
		
			einfo "Updating $ESVN_PROJECT trunk from $ESVN_REPO_URI"
			echo "Executing ${ESVN_UPDATE_CMD} $ESVN_UPDATE_OPTS"
			${ESVN_UPDATE_CMD} $ESVN_UPDATE_OPTS || die "${ESVN}: can't update from ${ESVN_REPO_URI}."

		fi

	fi

	cd $ESVN_STORE_DIR/$ESVN_CO_DIR
	sort_items $ESVN_REPO_URI

	for (( level=0; $level <= $deep_levels || $level <= $shallow_levels ; level=$level+1 ))
	do

		if (( $level <= $deep_levels )); then

			for module in ${deep_items[$level]}
			do

				echo "Deep module at level $level: $module"
				subversion_module_fetch_direct "$module"

			done

		fi

		if (( $level <= $shallow_levels )); then

			for module in ${shallow_items[$level]}
			do

				echo "Shallow module at level $level: $module"
				subversion_module_fetch_direct "$module" "-N"

			done

		fi

	done
			

	#for item in $ESCM_SHALLOWITEMS $ESCM_DEEPITEMS
	#do

	#		item_type "$ESCM_ROOT/$item" $ESVN_REPO_URI

	#done

	#for module in $ESVN_MODULES
	#do

	#	if [ -z $ESCM_ROOT ] || [ $ESCM_ROOT == "" ]; then
	#		subversion_module_fetch $module
	#	else
	#		subversion_module_fetch	$ESCM_ROOT/$module
	#	fi

	#done


	src_to_workdir "$ESVN_STORE_DIR/$ESVN_CO_DIR/$ESCM_ROOT" subversion_deep_copy

}

function sort_items() {

	debug-print-function $FUNCNAME $*

	url=$1

	deep_levels=0
	shallow_levels=0

	for item in $ESCM_SHALLOWITEMS $ESCM_DEEPITEMS
	do
		
		declare -i token=0 next_token=1 level=0

		local path="$ESCM_ROOT/$item"

		while [ $next_token != 0 ]
		do

			local topdir=`echo ${path:0:$token} | sed -e "s/\/*$//g"`

			# Determine index of character after next /
			next_token=`expr index ${path:$token} "/"`

			# If last level in hierarchy of $path
			if [ $next_token == 0 ]; then
			
				item_type $path $url
				case $? in
				$DNE)
					
					debug-print "$item does not exist and will not be added for checkout/update"
				
				;;	
				$FIL)

					debug-print "$item is a file, and will not be added for checkout/update"

				;;
				$DIR)

					# If item is deep, add $level ancestor to array of deep items at $level
					if ( hasq "$item" $ESCM_DEEPITEMS ); then

						if ( ! hasq "$path" ${deep_items[$level]} ); then

							debug-print "Adding $path to array of deep items at level $level"
							[ $deep_levels -le $level ]  && deep_items[$level]="" && deep_levels=$level
							deep_items[$level]="$path ${deep_items[$level]}"

						fi

					else
					
						if ( ! hasq "$path" ${shallow_items[$level]} ); then
				
							debug-print "Adding $path to array of shallow items at level $level"
							[ $shallow_levels -le $level ] && shallow_items[$level]="" && shallow_levels=$level
							shallow_items[$level]="$path ${shallow_items[$level]}"
	
						fi
	
					fi
					
				;;
				esac

			else

				if ( ! hasq "$topdir" ${shallow_items[$level]} ${deep_items[$level]} ); then
				
					debug-print "Adding $topdir to array of shallow items at level $level"
					[ $shallow_levels -le $level ] && shallow_items[$level]="" && shallow_levels=$level
					shallow_items[$level]="$topdir ${shallow_items[$level]}"

				fi

			fi 

			# Move $token index by $next_token
			token=$token+$next_token

			# Advance to next $level
			level=$level+1
			
		done

	done

}

## -- subversion_bootstrap() ------------------------------------------------ #

function subversion_bootstrap() {

	local patch lpatch

	cd "${S}"

	if [ "${ESVN_PATCHES}" ]; then
		einfo "apply patches -->"

		for patch in ${ESVN_PATCHES}; do
			if [ -f "${patch}" ]; then
				epatch ${patch}

			else
				for lpatch in ${FILESDIR}/${patch}; do
					if [ -f "${lpatch}" ]; then
						epatch ${lpatch}

					else
						die "${ESVN}; ${patch} is not found"

					fi
				done
			fi
		done
		echo
	fi

	if [ "${ESVN_BOOTSTRAP}" ]; then
		einfo "begin bootstrap -->"

		if [ -f "${ESVN_BOOTSTRAP}" -a -x "${ESVN_BOOTSTRAP}" ]; then
			einfo "   bootstrap with a file: ${ESVN_BOOTSTRAP}"
			eval "./${ESVN_BOOTSTRAP}" || die "${ESVN}: can't execute ESVN_BOOTSTRAP."

		else
			einfo "   bootstrap with commands: ${ESVN_BOOTSTRAP}"
			eval "${ESVN_BOOTSTRAP}" || die "${ESVN}: can't eval ESVN_BOOTSTRAP."

		fi
	fi

}


## -- subversion_src_unpack() ------------------------------------------------ #

function subversion_src_unpack() {

	subversion_svn_fetch || die "${ESVN}: unknown problem in subversion_svn_fetch()."
	subversion_bootstrap || die "${ESVN}: unknown problem in subversion_bootstrap()."

}
